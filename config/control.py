"""
@file device_control.py
@brief A Python script to control Tuya IoT devices through the API (for the 4 gang switch).
@details This script provides functionality to send control commands to Tuya devices
         using the Tuya IoT API with HMAC-SHA256 authentication. It supports
         controlling device switches and other boolean states.

@author Nishan Dananjaya
@date 2025-02-13
@version 1.0
"""

import os 
import time 
import hmac
import hashlib
import requests
import uuid
import json
from dotenv import load_dotenv

# Specify the path to the .env file in the project root directory
dot_env_path = os.path.join(os.path.dirname(__file__), '..', '.env')
load_dotenv(dot_env_path)

def generate_signature(client_id, secret, access_token, t, nonce, url, method="POST", body=""):
    """
    @brief Generate the HMAC-SHA256 signature for Tuya API requests.
    
    @details Creates a signature for authenticating requests to the Tuya API using
             HMAC-SHA256. The signature is generated by combining various request
             parameters and creating a hash of the body content.
    
    @param client_id str The client ID (Access ID) provided by Tuya
    @param secret str The client secret (Access Key) provided by Tuya
    @param access_token str The access token for API authentication
    @param t str Timestamp in milliseconds
    @param nonce str A unique identifier for the request
    @param url str The API endpoint URL
    @param method str The HTTP method (default: "POST")
    @param body str The request body as a JSON string (default: "")
    
    @return str The generated HMAC-SHA256 signature in uppercase hexadecimal format
    
    @note The signature is crucial for API authentication and must be included
          in the request headers
    """
    headers_str = ""  # No special headers needed for signing
    body_hash = hashlib.sha256(body.encode('utf-8')).hexdigest()
    
    string_to_sign = method + "\n" + \
                     body_hash + "\n" + \
                     headers_str + "\n" + \
                     url
    
    str_to_sign = client_id + access_token + t + nonce + string_to_sign
    
    signature = hmac.new(
        secret.encode('utf-8'),
        str_to_sign.encode('utf-8'),
        hashlib.sha256
    ).hexdigest().upper()
    
    return signature

def control_device(url, client_id, secret, access_token, device_id, switch, command):
    """
    @brief Send a command to control a Tuya device.
    
    @details Sends a control command to a specific Tuya device through the IoT API.
             The function handles authentication, request signing, and command execution.
             It supports boolean control commands (true/false) for device switches.
    
    @param url str The base URL of the Tuya API
    @param client_id str The client ID (Access ID) provided by Tuya
    @param secret str The client secret (Access Key) provided by Tuya
    @param access_token str The access token for API authentication
    @param device_id str The ID of the device to control
    @param switch str The switch identifier (e.g., "switch_1")
    @param command str The command to send ("true" or "false")
    
    @return dict|None Returns the JSON response from the API if successful,
                     None if the request fails
    
    @exception requests.exceptions.RequestException Raised when the API request fails
    
    @note Debug information including URL, timestamp, nonce, body, signature,
          and response details are printed to the console
    """
    t = str(int(time.time() * 1000))
    nonce = str(uuid.uuid4())

    endpoint = f"/v1.0/iot-03/devices/{device_id}/commands"
    full_url = f"{url}{endpoint}"

    payload = {
        "commands": [
            {"code": switch, "value": command.lower() == "true"}
        ]
    }
    
    body = json.dumps(payload)
    signature = generate_signature(client_id, secret, access_token, t, nonce, endpoint, body=body)

    headers = {
        'client_id': client_id,
        't': t,
        'sign': signature,
        'sign_method': 'HMAC-SHA256',
        'nonce': nonce,
        'access_token': access_token,
        'Content-Type': 'application/json'
    }

    try:
        response = requests.post(full_url, headers=headers, json=payload)

        print(f"Request URL: {full_url}")
        print(f"Timestamp: {t}")
        print(f"Nonce: {nonce}")
        print(f"Body: {body}")
        print(f"Signature: {signature}")
        print(f"Response Status Code: {response.status_code}")
        print(f"Response Body: {response.text}")

        return response.json()

    except requests.exceptions.RequestException as e:
        print(f"Request failed: {e}")
        return None

if __name__ == "__main__":
    """
    @brief Main entry point for the device control script.
    
    @details Loads environment variables and executes device control based on user input.
             Required environment variables:
             - TUYA_BASE_URL: The base URL for the Tuya API
             - TUYA_ACCESS_ID: The client ID provided by Tuya
             - TUYA_ACCESS_KEY: The client secret provided by Tuya
             - ACCESS_TOKEN: The access token for authentication
             - DEVICE_ID: The ID of the device to control
    
    @note Prompts the user for the switch to control and the command to send
    """
    API_URL = os.getenv("TUYA_BASE_URL")
    CLIENT_ID = os.getenv("TUYA_ACCESS_ID")
    SECRET = os.getenv("TUYA_ACCESS_KEY")
    ACCESS_TOKEN = os.getenv("ACCESS_TOKEN")
    DEVICE_ID = os.getenv("DEVICE_ID")

    if not all([API_URL, CLIENT_ID, SECRET, ACCESS_TOKEN, DEVICE_ID]):
        print("Error: Missing required environment variables in .env file.")
    else:
        switch = input("Enter what to control (e.g., switch_1): ")
        command = input("Enter the command (e.g., true/false): ")

        result = control_device(API_URL, CLIENT_ID, SECRET, ACCESS_TOKEN, DEVICE_ID, switch, command)
        print("\nDevice Control Response:", result)